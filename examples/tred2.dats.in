(*

Copyright © 2021 Barry Schwartz

This program is free software: you can redistribute it and/or
modify it under the terms of the GNU General Public License, as
published by the Free Software Foundation, either version 3 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received copies of the GNU General Public License
along with this program. If not, see
<https://www.gnu.org/licenses/>.

*)

#define ATS_DYNLOADFLAG 0

#include "share/atspre_define.hats"
#include "share/atspre_staload.hats"

#include "floattypes/HATS/floattypes.hats"

staload "proofs.sats"
staload "array2d.sats"
staload "tred2.sats"

implement {tk}
tred2 {nm, n} {na} {nd} {ne} {nz}
      (nm, n, a, d, e, z) =
  if i2sz 0 < n then
    let
      (* The arrays have extent. *)
      prval _ = mul_gte_gte_gte {nm, n - 1} ()
      prval _ = prop_verify {0 < nm * n} ()

      typedef flt = g0float(tk)
      macdef i2f = g0int2float

      fn
      get {narr : int | nm * n <= narr}
          {i, j : nat | i < nm; j < n}
          (arr  : &array(flt, narr),
           i    : size_t i,
           j    : size_t j) :<!ref> flt =
        arr2get {nm, n} (nm, arr, i, j)

      fn
      put {narr : int | nm * n <= narr}
          {i, j : nat | i < nm; j < n}
          (arr  : &array(flt, narr),
           i    : size_t i,
           j    : size_t j,
           x    : flt) :<!refwrt> void =
        arr2put {nm, n} (nm, arr, i, j, x)

      overload [] with get of 1000
      overload [] with put of 1000

      typedef vars_t =
        @{
          f = flt,
          g = flt,
          h = flt,
          hh = flt,
          scale = flt
        }
      var vars : vars_t =
        @{
          f = nan(""),
          g = nan(""),
          h = nan(""),
          hh = nan(""),
          scale = nan("")
        }

      extern fun {k0, k1 : int}
      forloop$action {k      : int | k0 <= k; k <= k1;
                                     0 <= k0; k0 <= k1; k1 < n}
                     (d      : &array(flt, nd),
                      e      : &array(flt, ne),
                      z      : &array(flt, nz),
                      vars   : &vars_t,
                      k      : size_t k) : void
      fn
      forloop {k0, k1 : int | 0 <= k0; k0 <= k1; k1 < n}
              (d    : &array(flt, nd),
               e    : &array(flt, ne),
               z    : &array(flt, nz),
               vars : &vars_t,
               k0     : size_t k0,
               k1     : size_t k1) : void =
        let
          fun
          loop {k    : int | k0 <= k; k <= k1} .<k1 - k>.
               (d    : &array(flt, nd),
                e    : &array(flt, ne),
                z    : &array(flt, nz),
                vars : &vars_t,
                k    : size_t k) : void =
            begin
              forloop$action<k0, k1>(d, e, z, vars, k);
              if k < k1 then
                loop(d, e, z, vars, succ k)
            end
        in
          loop(d, e, z, vars, k0)
        end

      extern fun {k0, k1 : int}
      forloop_down$action {k      : int | k1 <= k; k <= k0;
                                          0 <= k1; k1 <= k0; k0 < n}
                          (d      : &array(flt, nd),
                           e      : &array(flt, ne),
                           z      : &array(flt, nz),
                           vars   : &vars_t,
                           k      : size_t k) : void
      fn
      forloop_down {k0, k1 : int | 0 <= k1; k1 <= k0; k0 < n}
                   (d    : &array(flt, nd),
                    e    : &array(flt, ne),
                    z    : &array(flt, nz),
                    vars : &vars_t,
                    k0     : size_t k0,
                    k1     : size_t k1) : void =
        let
          fun
          loop {k    : int | k1 <= k; k <= k0} .<k - k1>.
               (d    : &array(flt, nd),
                e    : &array(flt, ne),
                z    : &array(flt, nz),
                vars : &vars_t,
                k    : size_t k) : void =
            begin
              forloop_down$action<k0, k1>(d, e, z, vars, k);
              if k1 < k then
                loop(d, e, z, vars, pred k)
            end
        in
          loop(d, e, z, vars, k0)
        end

      fn
      action1 {i    : int | 1 <= i; i < n}
              (d    : &array(flt, nd),
               e    : &array(flt, ne),
               z    : &array(flt, nz),
               vars : &vars_t,
               i    : size_t i) : void =
      let
        fn
        simple_situation (d : &array(flt, nd),
                          e : &array(flt, ne),
                          z : &array(flt, nz)) : void =
          let
            fun
            loop {j : int | 0 <= j; j <= i} .<i - j>.
                 (d : &array(flt, nd),
                  z : &array(flt, nz),
                  j : size_t j) : void =
              if j < i then
                begin
                  d[j] := z[pred i, j];
                  z[i, j] := g0int2float 0;
                  z[j, i] := g0int2float 0;
                  loop(d, z, succ j)
                end
          in
            e[i] := d[pred i];
            loop(d, z, i2sz 0)
          end
        val _ = vars.h := i2f 0;
      in
        if i = i2sz 1 then
          simple_situation(d, e, z)
        else
          let
            implement
            forloop$action<0, i - 1>(d, e, z, vars, k) =
              vars.scale := vars.scale + abs(d[k])
            val _ = vars.scale := i2f 0
            val _ = forloop(d, e, z, vars, i2sz 0, pred i)
          in
            if vars.scale = i2f 0 then
              simple_situation(d, e, z)
            else
              let
                /*
                 * Scale the row. (Doing this is an improvement on the
                 * original Algol 60 code, and eliminates need for the
                 * ‘tol’ parameter employed there.
                 */
                implement
                forloop$action<0, i - 1>(d, e, z, vars, k) =
                  begin
                    d[k] := d[k] / vars.scale;
                    vars.h := vars.h + (d[k] * d[k])
                  end
                val _ = forloop(d, e, z, vars, i2sz 0, pred i)

                val _ = vars.f := d[i - 1]
                val _ = vars.g := neg(copysign(sqrt(vars.h), vars.f))
                val _ = e[i] := vars.scale * vars.g
                val _ = vars.h := vars.h - (vars.f * vars.g)
                val _ = d[i - 1] := vars.f - vars.g

                /*
                 * Form a*u.
                 */
                implement
                forloop$action<0, i - 1>(d, e, z, vars, j) =
                  e[j] := i2f 0
                val _ = forloop(d, e, z, vars, i2sz 0, pred i)
                implement
                forloop$action<0, i - 1>{j}(d, e, z, vars, j) =
                  let
                    val _ = vars.f := d[j];
                    val _ = z[j, i] := vars.f;
                    val _ = vars.g := e[j] + (z[j, j] * vars.f);
                  in
                    if succ j <= pred i then
                      let
                        implement
                        forloop$action<j + 1, i - 1>(d, e, z, vars, k) =
                          begin
                            vars.g := vars.g + (z[k, j] * d[k]);
                            e[k] := e[k] + (z[k, j] * vars.f)
                          end
                        val _ = forloop(d, e, z, vars, succ j, pred i)
                        val _ = e[j] := vars.g
                      in
                      end
                  end
                val _ = forloop(d, e, z, vars, i2sz 0, pred i)

                /*
                 * Form p.
                 */
                val _ = vars.f := i2f 0
                implement
                forloop$action<0, i - 1>(d, e, z, vars, j) =
                  begin
                    e[j] := e[j] / vars.h;
                    vars.f := vars.f + (e[j] * d[j])
                  end
                val _ = forloop(d, e, z, vars, i2sz 0, pred i)

                /*
                 * Form q.
                 */
                val _ = vars.hh := vars.f / (vars.h + vars.h)
                implement
                forloop$action<0, i - 1>(d, e, z, vars, j) =
                  e[j] := e[j] - (vars.hh * d[j])
                val _ = forloop(d, e, z, vars, i2sz 0, pred i)

                /*
                 * Form reduced a.
                 */
                implement
                forloop$action<0, i - 1>{j}(d, e, z, vars, j) =
                  let
                    val _ = vars.f := d[j]
                    val _ = vars.g := e[j]
                    implement
                    forloop$action<j, i - 1>(d, e, z, vars, k) =
                      begin
                        z[k, j] := z[k, j] - (vars.f * e[k]);
                        z[k, j] := z[k, j] - (vars.g * d[k])
                      end
                    val _ = forloop(d, e, z, vars, j, pred i)
                    val _ = d[j] := z[i - 1, j]
                    val _ = z[i, j] = i2f 0
                  in
                  end
                val _ = forloop(d, e, z, vars, i2sz 0, pred i)
              in
              end
          end;

        d[i] := vars.h
      end

    in

      arr2copy_lower_triangle {nm, n} (nm, n, a, z);

      if i2sz 1 <= n then
        begin
          if i2sz 2 <= n then
            let
              implement
              forloop_down$action<n - 1, 1>(d, e, z, vars, i) =
                action1(d, e, z, vars, i)
            in
              forloop_down(d, e, z, vars, pred n, i2sz 1)
            end
        end
    end
