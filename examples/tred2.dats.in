(*

Copyright © 2021 Barry Schwartz

This program is free software: you can redistribute it and/or
modify it under the terms of the GNU General Public License, as
published by the Free Software Foundation, either version 3 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received copies of the GNU General Public License
along with this program. If not, see
<https://www.gnu.org/licenses/>.

*)

#define ATS_DYNLOADFLAG 0

#include "share/atspre_define.hats"
#include "share/atspre_staload.hats"

#include "floattypes/HATS/floattypes.hats"

staload "proofs.sats"
staload "array2d.sats"
staload "tred2.sats"

implement {tk}
tred2 {nm, n} {na} {nd} {ne} {nz}
      (nm, n, a, d, e, z) =
  if i2sz 0 < n then
    let
      (* The arrays have extent. *)
      prval _ = mul_gte_gte_gte {nm, n - 1} ()
      prval _ = prop_verify {0 < nm * n} ()

      typedef flt = g0float(tk)
      macdef i2f = g0int2float

      fn
      get {narr : int | nm * n <= narr}
          {i, j : nat | i < nm; j < n}
          (arr  : &array(flt, narr),
           i    : size_t i,
           j    : size_t j) :<!ref> flt =
        arr2get {nm, n} (nm, arr, i, j)

      fn
      put {narr : int | nm * n <= narr}
          {i, j : nat | i < nm; j < n}
          (arr  : &array(flt, narr),
           i    : size_t i,
           j    : size_t j,
           x    : flt) :<!refwrt> void =
        arr2put {nm, n} (nm, arr, i, j, x)

      overload [] with get of 1000
      overload [] with put of 1000

      var f : flt = nan("")
      var g : flt = nan("")
      var h : flt = nan("")
      var hh : flt = nan("")
      var scale : flt = nan("")
            
      extern fun {k0, k1 : int}
      forloop$action {k    : int | k0 <= k; k <= k1;
                                     0 <= k0; k0 <= k1; k1 < n}
                     (d    : &array(flt, nd),
                      e    : &array(flt, ne),
                      z    : &array(flt, nz),
                      k    : size_t k) : void
      fn
      forloop {k0, k1 : int | 0 <= k0; k0 <= k1; k1 < n}
              (d    : &array(flt, nd),
               e    : &array(flt, ne),
               z    : &array(flt, nz),
               k0   : size_t k0,
               k1   : size_t k1) : void =
        let
          fun
          loop {k    : int | k0 <= k; k <= k1} .<k1 - k>.
               (d    : &array(flt, nd),
                e    : &array(flt, ne),
                z    : &array(flt, nz),
                k    : size_t k) : void =
            begin
              forloop$action<k0, k1>(d, e, z, k);
              if k < k1 then
                loop(d, e, z, succ k)
            end
        in
          loop(d, e, z, k0)
        end

      extern fun {k0, k1 : int}
      forloop_down$action {k    : int | k1 <= k; k <= k0;
                                        0 <= k1; k1 <= k0; k0 < n}
                          (d    : &array(flt, nd),
                           e    : &array(flt, ne),
                           z    : &array(flt, nz),
                           k    : size_t k) : void
      fn
      forloop_down {k0, k1 : int | 0 <= k1; k1 <= k0; k0 < n}
                   (d    : &array(flt, nd),
                    e    : &array(flt, ne),
                    z    : &array(flt, nz),
                    k0   : size_t k0,
                    k1   : size_t k1) : void =
        let
          fun
          loop {k    : int | k1 <= k; k <= k0} .<k - k1>.
               (d    : &array(flt, nd),
                e    : &array(flt, ne),
                z    : &array(flt, nz),
                k    : size_t k) : void =
            begin
              forloop_down$action<k0, k1>(d, e, z, k);
              if k1 < k then
                loop(d, e, z, pred k)
            end
        in
          loop(d, e, z, k0)
        end

      fn
      action1 {i    : int | 1 <= i; i < n}
              (d    : &array(flt, nd),
               e    : &array(flt, ne),
               z    : &array(flt, nz),
               i    : size_t i) : void =
      let
        fn
        simple_situation (d : &array(flt, nd),
                          e : &array(flt, ne),
                          z : &array(flt, nz)) : void =
          let
            fun
            loop {j : int | 0 <= j; j <= i} .<i - j>.
                 (d : &array(flt, nd),
                  z : &array(flt, nz),
                  j : size_t j) : void =
              if j < i then
                begin
                  d[j] := z[pred i, j];
                  z[i, j] := g0int2float 0;
                  z[j, i] := g0int2float 0;
                  loop(d, z, succ j)
                end
          in
            e[i] := d[pred i];
            loop(d, z, i2sz 0)
          end
        val _ = h := i2f 0
      in
        if i = i2sz 1 then
          simple_situation(d, e, z)
        else
          let
            implement
            forloop$action<0, i - 1>(d, e, z, k) =
              scale := scale + abs(d[k])
            val _ = scale := i2f 0
            val _ = forloop(d, e, z, i2sz 0, pred i)
          in
            if scale = i2f 0 then
              simple_situation(d, e, z)
            else
              let
                (*
                 * Scale the row. (Doing this is an improvement on the
                 * original Algol 60 code, and eliminates need for the
                 * ‘tol’ parameter employed there.
                 *)
                implement
                forloop$action<0, i - 1>(d, e, z, k) =
                  begin
                    d[k] := d[k] / scale;
                    h := h + (d[k] * d[k])
                  end
                val _ = forloop(d, e, z, i2sz 0, pred i)

                val _ = f := d[i - 1]
                val _ = g := neg(copysign(sqrt(h), f))
                val _ = e[i] := scale * g
                val _ = h := h - (f * g)
                val _ = d[i - 1] := f - g

                (*
                 * Form a*u.
                 *)
                implement
                forloop$action<0, i - 1>(d, e, z, j) =
                  e[j] := i2f 0
                val _ = forloop(d, e, z, i2sz 0, pred i)
                implement
                forloop$action<0, i - 1>{j}(d, e, z, j) =
                  let
                    val _ = f := d[j];
                    val _ = z[j, i] := f;
                    val _ = g := e[j] + (z[j, j] * f);
                  in
                    if succ j <= pred i then
                      let
                        implement
                        forloop$action<j + 1, i - 1>(d, e, z, k) =
                          begin
                            g := g + (z[k, j] * d[k]);
                            e[k] := e[k] + (z[k, j] * f)
                          end
                        val _ = forloop(d, e, z, succ j, pred i)
                        val _ = e[j] := g
                      in
                      end
                  end
                val _ = forloop(d, e, z, i2sz 0, pred i)

                (*
                 * Form p.
                 *)
                val _ = f := i2f 0
                implement
                forloop$action<0, i - 1>(d, e, z, j) =
                  begin
                    e[j] := e[j] / h;
                    f := f + (e[j] * d[j])
                  end
                val _ = forloop(d, e, z, i2sz 0, pred i)

                (*
                 * Form q.
                 *)
                val _ = hh := f / (h + h)
                implement
                forloop$action<0, i - 1>(d, e, z, j) =
                  e[j] := e[j] - (hh * d[j])
                val _ = forloop(d, e, z, i2sz 0, pred i)

                (*
                 * Form reduced a.
                 *)
                implement
                forloop$action<0, i - 1>{j}(d, e, z, j) =
                  let
                    val _ = f := d[j]
                    val _ = g := e[j]
                    implement
                    forloop$action<j, i - 1>(d, e, z, k) =
                      begin
                        z[k, j] := z[k, j] - (f * e[k]);
                        z[k, j] := z[k, j] - (g * d[k])
                      end
                    val _ = forloop(d, e, z, j, pred i)
                    val _ = d[j] := z[i - 1, j]
                    val _ = z[i, j] = i2f 0
                  in
                  end
                val _ = forloop(d, e, z, i2sz 0, pred i)
              in
              end
          end;

        d[i] := h
      end

      fn
      accumulation_of_transformation_matrices_action
                                        {i    : int | 1 <= i; i < n}
                                        (d    : &array(flt, nd),
                                         e    : &array(flt, ne),
                                         z    : &array(flt, nz),
                                         i    : size_t i) : void =
        let
          val _ = z[pred n, pred i] := z[pred i, pred i]
          val _ = z[pred i][pred i] := i2f 1
          val _ = h := d[i]
        in
          if h <> i2f 0 then
            let
              implement
              forloop$action<0, i - 1>(d, e, z, k) =
                d[k] := z[k, i] / h
              val _ = forloop(d, e, z, i2sz 0, pred i)
              implement
              forloop$action<0, i - 1>(d, e, z, j) =
                let
                  val _ = g := i2f 0
                  implement
                  forloop$action<0, i - 1>(d, e, z, k) =
                    g := g + (z[k, i] * z[k, j])
                  val _ = forloop(d, e, z, i2sz 0, pred i)
                  implement
                  forloop$action<0, i - 1>(d, e, z, k) =
                    z[k, j] := z[k, j] - (g * d[k])
                  val _ = forloop(d, e, z, i2sz 0, pred i)
                in
                end
              val _ = forloop(d, e, z, i2sz 0, pred i)
            in
            end;
          let
            implement
            forloop$action<0, i - 1>(d, e, z, k) =
              z[k, i] := i2f 0
            val _ = forloop(d, e, z, i2sz 0, pred i)
          in
          end
        end

    in

      arr2copy_lower_triangle {nm, n} (nm, n, a, z);

      if i2sz 2 <= n then
        let
          implement
          forloop_down$action<n - 1, 1> =
            action1
          val _ = forloop_down(d, e, z, pred n, i2sz 1)

          implement
          forloop$action<1, n - 1> =
            accumulation_of_transformation_matrices_action
          val _ = forloop(d, e, z, i2sz 1, pred n)
        in
        end;

      if i2sz 1 <= n then
        let
          implement
          forloop$action<0, n - 1>(d, e, z, i) =
            begin
              d[i] := z[pred n, i];
              z[pred n, i] := i2f 0
            end
          val _ = forloop(d, e, z, i2sz 0, pred n)
        in
        end;
      z[pred n, pred n] := i2f 1;
      e[i2sz 0] := i2f 0
    end
