(*

Copyright © 2021 Barry Schwartz

This program is free software: you can redistribute it and/or
modify it under the terms of the GNU General Public License, as
published by the Free Software Foundation, either version 3 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received copies of the GNU General Public License
along with this program. If not, see
<https://www.gnu.org/licenses/>.

*)

(*
  FIXME: Rewrite copy_lower_triangle to have <!refwrt> effects.
  FIXME: Make the entire thing <!refwrt>.
  FIXME: Come up with better names.
  FIXME: Eliminate ‘var’ variables.
  FIXME: Wrap this so one can use uninitialized arrays.
           (We can initialize just the portion used,
            without rewriting this all to handle
            uninitialized arrays.)
*)

#define ATS_DYNLOADFLAG 0

#include "share/atspre_define.hats"
#include "share/atspre_staload.hats"

#include "floattypes/HATS/floattypes.hats"

staload "proofs.sats"
staload "array2d.sats"
staload "tred2.sats"

implement {tk}
tred2 {nm, n} {na} {nd} {ne} {nz}
      (nm, n, a, d, e, z) =
  if i2sz 0 < n then
    let
      (* The arrays have extent. *)
      prval _ = mul_gte_gte_gte {nm, n - 1} ()
      prval _ = prop_verify {0 < nm * n} ()

      typedef flt = g0float(tk)
      macdef i2f = g0int2float

      fn
      get {narr : int | nm * n <= narr}
          {i, j : nat | i < nm; j < n}
          (arr  : &array(flt, narr),
           i    : size_t i,
           j    : size_t j) :<!ref> flt =
        arr2get {nm, n} (nm, arr, i, j)

      fn
      put {narr : int | nm * n <= narr}
          {i, j : nat | i < nm; j < n}
          (arr  : &array(flt, narr),
           i    : size_t i,
           j    : size_t j,
           x    : flt) :<!refwrt> void =
        arr2put {nm, n} (nm, arr, i, j, x)

      overload [] with get of 1000
      overload [] with put of 1000

      fn
      action1 {i    : int | 1 <= i; i < n}
              (d    : &array(flt, nd),
               e    : &array(flt, ne),
               z    : &array(flt, nz),
               i    : size_t i) :<!refwrt> void =
      let
        var f : flt = nan("")
        var g : flt = nan("")
        var h : flt = nan("")

        fn
        simple_situation (d : &array(flt, nd),
                          e : &array(flt, ne),
                          z : &array(flt, nz)) :<!refwrt> void =
          let
            fun
            loop {j : int | 0 <= j; j <= i} .<i - j>.
                 (d : &array(flt, nd),
                  z : &array(flt, nz),
                  j : size_t j) :<!refwrt> void =
              if j < i then
                begin
                  d[j] := z[pred i, j];
                  z[i, j] := i2f 0;
                  z[j, i] := i2f 0;
                  loop(d, z, succ j)
                end
          in
            e[i] := d[pred i];
            loop(d, z, i2sz 0)
          end
      in
        h := i2f 0;

        if i = i2sz 1 then
          simple_situation(d, e, z)
        else
          let
            fun
            loop {k : int | 0 <= k; k <= i} .<i - k>.
                 (d     : &array(flt, nd),
                  scale : flt,
                  k     : size_t k) :<!ref> flt =
              if k = i then
                scale
              else
                loop (d, scale + abs(d[k]), succ k)
            val scale = loop (d, i2f 0, i2sz 0)
          in
            if scale = i2f 0 then
              simple_situation(d, e, z)
            else
              let
                (*
                 * Scale the row. (Doing this is an improvement on the
                 * original Algol 60 code, and eliminates need for the
                 * ‘tol’ parameter employed there.
                 *)
                fun
                loop {k : int | 0 <= k; k <= i} .<i - k>.
                     (d : &array(flt, nd),
                      h : &flt,
                      k : size_t k) :<!refwrt> void =
                  if k < i then
                    begin
                      d[k] := d[k] / scale;
                      h := h + (d[k] * d[k]);
                      loop (d, h, succ k)
                    end
                val _ = loop (d, h, i2sz 0)

                val _ =
                  let
                    val f_ = d[i - 1]
                    val g_ = neg(copysign(sqrt(h), f_))
                  in
                    e[i] := scale * g_;
                    h := h - (f_ * g_);
                    d[i - 1] := f_ - g_
                  end

                (*
                 * Form a*u.
                 *)
                fun
                loop {j : int | 0 <= j; j <= i} .<i - j>.
                     (e : &array(flt, ne),
                      j : size_t j) :<!refwrt> void =
                  if i < j then
                    begin
                      e[j] := i2f 0;
                      loop (e, succ j)
                    end
                val _ = loop (e, i2sz 0)
                fun
                loop {j : int | 0 <= j; j <= i} .<i - j>.
                     (d : &array(flt, nd),
                      e : &array(flt, ne),
                      z : &array(flt, nz),
                      j : size_t j) :<!refwrt> void =
                  if j < i then
                    let
                      var f : flt = d[j];
                      val _ = z[j, i] := f;
                      var g : flt = e[j] + (z[j, j] * f);
                    in
                      if succ j <= pred i then
                        let
                          fun
                          loop1 {k : int | j + 1 <= k; k <= i} .<i - k>.
                                (d : &array(flt, nd),
                                 e : &array(flt, ne),
                                 z : &array(flt, nz),
                                 g : &flt,
                                 f : &flt,
                                 k : size_t k) :<!refwrt> void =
                            if k < i then
                              begin
                                g := g + (z[k, j] * d[k]);
                                e[k] := e[k] + (z[k, j] * f);
                                loop1 (d, e, z, g, f, succ k)
                              end
                          val _ = loop1 (d, e, z, g, f, succ j)
                          val _ = e[j] := g
                        in
                        end;
                      loop (d, e, z, succ j)
                    end
                  val _ = loop (d, e, z, i2sz 0)

                (*
                 * Form p.
                 *)
                val _ = f := i2f 0
                fun
                loop {j : int | 0 <= j; j <= i} .<i - j>.
                     (d : &array(flt, nd),
                      e : &array(flt, ne),
                      f : &flt,
                      h : &flt,
                      j : size_t j) :<!refwrt> void =
                  if j < i then
                    begin
                      e[j] := e[j] / h;
                      f := f + (e[j] * d[j]);
                      loop (d, e, f, h, succ j)
                    end
                val _ = loop (d, e, f, h, i2sz 0)

                (*
                 * Form q.
                 *)
                val hh = f / (h + h)
                fun
                loop {j : int | 0 <= j; j <= i} .<i - j>.
                     (d : &array(flt, nd),
                      e : &array(flt, ne),
                      j : size_t j) :<!refwrt> void =
                  if j < i then
                    begin
                      e[j] := e[j] - (hh * d[j]);
                      loop (d, e, succ j)
                    end
                val _ = loop (d, e, i2sz 0)

                (*
                 * Form reduced a.
                 *)
                fun
                loop {j : int | 0 <= j; j <= i} .<i - j>.
                     (d : &array(flt, nd),
                      e : &array(flt, ne),
                      z : &array(flt, nz),
                      j : size_t j) :<!refwrt> void =
                  if j < i then
                    let
                      val f_ = d[j]
                      val g_ = e[j]

                      fun
                      loop1 {k : int | j <= k; k <= i} .<i - k>.
                            (d : &array(flt, nd),
                             e : &array(flt, ne),
                             z : &array(flt, nz),
                             k : size_t k) :<!refwrt> void =
                        if k < i then
                          begin
                            z[k, j] := z[k, j] - (f_ * e[k]);
                            z[k, j] := z[k, j] - (g_ * d[k]);
                            loop1 (d, e, z, succ k)
                          end
                      val _ = loop1 (d, e, z, j)

                      val _ = d[j] := z[i - 1, j]
                      val _ = z[i, j] = i2f 0
                    in
                      loop (d, e, z, succ j)
                    end
                val _ = loop (d, e, z, i2sz 0)
              in
              end
          end;

        d[i] := h
      end

      fn
      accumulation_of_transformation_matrices_action
                                        {i : int | 1 <= i; i < n}
                                        (d : &array(flt, nd),
                                         e : &array(flt, ne),
                                         z : &array(flt, nz),
                                         i : size_t i) :<!refwrt> void =
        let
          var g : flt = nan("")
          var h : flt = nan("")

          val _ = z[pred n, pred i] := z[pred i, pred i]
          val _ = z[pred i][pred i] := i2f 1
          val _ = h := d[i]
        in
          if h <> i2f 0 then
            let
              fun
              loop {k : int | 0 <= k; k <= i} .<i - k>.
                   (d : &array(flt, nd),
                    z : &array(flt, nz),
                    h : &flt,
                    k : size_t k) :<!refwrt> void =
                if k < i then
                  begin
                    d[k] := z[k, i] / h;
                    loop (d, z, h, succ k)
                  end
              val _ = loop (d, z, h, i2sz 0)

              fun
              loop {j : int | 0 <= j; j <= i} .<i - j>.
                   (d : &array(flt, nd),
                    z : &array(flt, nz),
                    g : &flt,
                    j : size_t j) :<!refwrt> void =
                if j < i then
                  let
                    val _ = g := i2f 0

                    fun
                    loop1 {k : int | 0 <= k; k <= i} .<i - k>.
                          (z : &array(flt, nz),
                           g : &flt,
                           k : size_t k) :<!refwrt> void =
                      if k < i then
                        begin
                          g := g + (z[k, i] * z[k, j]);
                          loop1 (z, g, succ k)
                        end
                    val _ = loop1(z, g, i2sz 0)

                    fun
                    loop2 {k : int | 0 <= k; k <= i} .<i - k>.
                          (d : &array(flt, nd),
                           z : &array(flt, nz),
                           g : &flt,
                           k : size_t k) :<!refwrt> void =
                      if k < i then
                        begin
                          z[k, j] := z[k, j] - (g * d[k]);
                          loop2 (d, z, g, succ k)
                        end
                    val _ = loop2 (d, z, g, i2sz 0)
                  in
                    loop (d, z, g, succ j)
                  end
            in
              loop (d, z, g, i2sz 0)
            end;
          let
            fun
            loop {k : int | 0 <= k; k <= i} .<i - k>.
                 (z : &array(flt, nz),
                  k : size_t k) :<!refwrt> void =
              if k < i then
                begin
                  z[k, i] := i2f 0;
                  loop (z, succ k)
                end
            val _ = loop (z, i2sz 0)
          in
          end
        end

    in

      arr2copy_lower_triangle {nm, n} (nm, n, a, z);

      if i2sz 2 <= n then
        let
          fun
          loop {i : int | 0 <= i; i < n} .<i>.
               (d : &array(flt, nd),
                e : &array(flt, ne),
                z : &array(flt, nz),
                i : size_t i) :<!refwrt> void =
            if i2sz 0 < i then
              begin
                action1 (d, e, z, i);
                loop (d, e, z, pred i)
              end
          val _ = loop (d, e, z, pred n)

          fun
          loop {i : int | 1 <= i; i <= n} .<n - i>.
               (d : &array(flt, nd),
                e : &array(flt, ne),
                z : &array(flt, nz),
                i : size_t i) :<!refwrt> void =
            if i < n then
              begin
                accumulation_of_transformation_matrices_action
                  (d, e, z, i);
                loop (d, e, z, succ i)
              end
          val _ = loop (d, e, z, i2sz 1)
        in
        end;

      if i2sz 1 <= n then
        let
          fun
          loop {i : int | 0 <= i; i <= n} .<n - i>.
               (d : &array(flt, nd),
                z : &array(flt, nz),
                i : size_t i) :<!refwrt> void =
            if i < n then
              begin
                d[i] := z[pred n, i];
                z[pred n, i] := i2f 0;
                loop (d, z, succ i)
              end
          val _ = loop (d, z, i2sz 0)
        in
        end;
      z[pred n, pred n] := i2f 1;
      e[i2sz 0] := i2f 0
    end
