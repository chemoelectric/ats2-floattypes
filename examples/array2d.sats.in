(*

Copyright Â© 2021 Barry Schwartz

This program is free software: you can redistribute it and/or
modify it under the terms of the GNU General Public License, as
published by the Free Software Foundation, either version 3 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received copies of the GNU General Public License
along with this program. If not, see
<https://www.gnu.org/licenses/>.

*)

(*
 * Column-major array access, for m-by-n arrays.
 *
 * Reverse the order of indices to get row-major access.
 *)

fn {t : t@ype}
arr2get {m, n : int}
        {na   : int | m * n <= na}
        {i, j : int | i < m; j < n}
        (m    : size_t m,
         a    : &array(t, na),
         i    : size_t i,
         j    : size_t j) :<!ref> t

fn {t : t@ype}
arr2put {m, n : int}
        {na   : int | m * n <= na}
        {i, j : int | i < m; j < n}
        (m    : size_t m,
         a    : &array(t, na),
         i    : size_t i,
         j    : size_t j,
         x    : t) :<!refwrt> void

(*
 * Operations on arrays of the kind above.
 *)

(* Copy a q-by-r block from one array to another,
   starting at (i1,j1) in the source array a1 and
   (i2,j2) in the destination array a2.   
   This is just arr2map_block with a do-nothing filter. *)
fn {t : t@ype}
arr2copy_block {m, n1, n2 : int}
               {na1, na2  : int | m * n1 <= na1; m * n2 <= na2}
               {q, r      : int}
               {i1, j1    : int | i1 + q <= m; j1 + r <= n1}
               {i2, j2    : int | i2 + q <= m; j2 + r <= n2}
               (m  : size_t m,
                a1 : &array(t, na1),
                a2 : &array(t, na2),
                q  : size_t q,
                r  : size_t r,
                i1 : size_t i1,
                j1 : size_t j1,
                i2 : size_t i2,
                j2 : size_t j2) : void

(* Map a q-by-r block from one array to another,
   starting at (i1,j1) in the source array a1 and
   (i2,j2) in the destination array a2. *)
fun {t : t@ype}
arr2map_block$filter : t -> t
fn {t : t@ype}
arr2map_block {m, n1, n2 : int}
              {na1, na2  : int | m * n1 <= na1; m * n2 <= na2}
              {q, r      : int}
              {i1, j1    : int | i1 + q <= m; j1 + r <= n1}
              {i2, j2    : int | i2 + q <= m; j2 + r <= n2}
              (m  : size_t m,
               a1 : &array(t, na1),
               a2 : &array(t, na2),
               q  : size_t q,
               r  : size_t r,
               i1 : size_t i1,
               j1 : size_t j1,
               i2 : size_t i2,
               j2 : size_t j2) : void

(* Copy the lower triangle of a1 to a2. This is just
   arr2map_lower_triangle with a do-nothing filter. *)
fn {t : t@ype}
arr2copy_lower_triangle {m, n     : int | n <= m}
                        {na1, na2 : int | m * n <= na1; m * n <= na2}
                        (m  : size_t m,
                         n  : size_t n,
                         a1 : &array(t, na1),
                         a2 : &array(t, na2)) : void

(* Map the lower triangle of a1 to a2, where m is the row dimension
   according to which the arrays are to be allocated, and n is the
   order of the matrix. (We are mimicking the storage pattern of
   the EISPACK Fortran code.) *)
fun {t : t@ype}
arr2map_lower_triangle$filter : t -> t
fn {t : t@ype}
arr2map_lower_triangle {m, n     : int | n <= m}
                       {na1, na2 : int | m * n <= na1; m * n <= na2}
                       (m  : size_t m,
                        n  : size_t n,
                        a1 : &array(t, na1),
                        a2 : &array(t, na2)) : void
