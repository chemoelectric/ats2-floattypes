(*

Copyright Â© 2021 Barry Schwartz

This program is free software: you can redistribute it and/or
modify it under the terms of the GNU General Public License, as
published by the Free Software Foundation, either version 3 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received copies of the GNU General Public License
along with this program. If not, see
<https://www.gnu.org/licenses/>.

*)

#include "share/atspre_define.hats"
#include "share/atspre_staload.hats"

#include "floattypes/HATS/floattypes.hats"

staload "arr2.sats"
staload _ = "arr2.dats"

staload "tred2.sats"
staload _ = "tred2.dats"

typedef flt = float128

fn
tred2_float128 {nm, n : nat | n <= nm}
               {na    : int | nm * n <= na}
               {nd    : int | n <= nd}
               {ne    : int | n <= ne}
               {nz    : int | nm * n <= nz}
               (nm    : size_t nm,
                n     : size_t n,
                a     : &array(float128, na),
                d     : &array(float128, nd),
                e     : &array(float128, ne),
                z     : &array(float128, nz)) : void =
  tred2<float128_kind>(nm, n, a, d, e, z)


(*
extern fn {t : t@ype}
arr2get {m, n : int}
        {na   : int | m * n <= na}
        {i, j : int | i < m; j < n}
        (m    : size_t m,
         a    : &(@[INV(t)][na]),
         i    : size_t i,
         j    : size_t j) :<ref> t

extern fn {t : t@ype}
arr2put {m, n : int}
        {na   : int | m * n <= na}
        {i, j : int | i < m; j < n}
        (m    : size_t m,
         a    : &(@[INV(t)][na]),
         i    : size_t i,
         j    : size_t j,
         x    : t) :<!refwrt> void

implement {t}
arr2get {m, n} {na} {i, j} (m, a, i, j) =
  let
    prval _ = lemma_g1uint_param (i) (* Establish that 0 <= i. *)
    prval _ = lemma_g1uint_param (j) (* Establish that 0 <= j. *)
    prval _ = mul_gte_gte_gte {j, m} ()
    prval _ = mul_compare_lte {j, n - 1, m} ()
    prval _ = prop_verify {0 <= i + (j * m) && i + (j * m) < na} ()
  in
    a[i + (j * m)]
  end

overload [] with arr2get of 1000
overload [] with arr2put of 1000
*)

implement
main () =
  let
(*
    var a : array(flt, 100) = @[flt][100] (nan(""))
    var d : array(flt, 10) = @[flt][10] (nan(""))
    var e : array(flt, 10) = @[flt][10] (nan(""))
    var z : array(flt, 100) = @[flt][100] (nan(""))
*)

(*
    val _ = arr2put {3, 3} (i2sz 3, a, i2sz 0, i2sz 0, f2f 1.0)
    val _ = arr2put {3, 3} (i2sz 3, a, i2sz 0, i2sz 1, f2f 2.0)
    val _ = arr2put {3, 3} (i2sz 3, a, i2sz 0, i2sz 2, f2f 3.0)
    val _ = arr2put {3, 3} (i2sz 3, a, i2sz 1, i2sz 0, f2f 4.0)
    val _ = arr2put {3, 3} (i2sz 3, a, i2sz 1, i2sz 1, f2f 5.0)
    val _ = arr2put {3, 3} (i2sz 3, a, i2sz 1, i2sz 2, f2f 6.0)
    val _ = arr2put {3, 3} (i2sz 3, a, i2sz 2, i2sz 0, f2f 7.0)
    val _ = arr2put {3, 3} (i2sz 3, a, i2sz 2, i2sz 1, f2f 8.0)
    val _ = arr2put {3, 3} (i2sz 3, a, i2sz 2, i2sz 2, f2f 9.0)

    val _ = arr2copy_lower_triangle (i2sz 3, i2sz 3, a, z)

    val _ = println!(arr2get {3, 3} (i2sz 3, z, i2sz 0, i2sz 0) : flt)
    val _ = println!(arr2get {3, 3} (i2sz 3, z, i2sz 0, i2sz 1) : flt)
    val _ = println!(arr2get {3, 3} (i2sz 3, z, i2sz 0, i2sz 2) : flt)
    val _ = println!(arr2get {3, 3} (i2sz 3, z, i2sz 1, i2sz 0) : flt)
    val _ = println!(arr2get {3, 3} (i2sz 3, z, i2sz 1, i2sz 1) : flt)
    val _ = println!(arr2get {3, 3} (i2sz 3, z, i2sz 1, i2sz 2) : flt)
    val _ = println!(arr2get {3, 3} (i2sz 3, z, i2sz 2, i2sz 0) : flt)
    val _ = println!(arr2get {3, 3} (i2sz 3, z, i2sz 2, i2sz 1) : flt)
    val _ = println!(arr2get {3, 3} (i2sz 3, z, i2sz 2, i2sz 2) : flt)

//    val _ = tred2_float128 (i2sz 3, i2sz 3, a, d, e, a)

    val _ = println!(arr2get {3, 3} (i2sz 3, a, i2sz 0, i2sz 0) : flt)
    val _ = println!(arr2get {3, 3} (i2sz 3, a, i2sz 0, i2sz 1) : flt)
    val _ = println!(arr2get {3, 3} (i2sz 3, a, i2sz 0, i2sz 2) : flt)
    val _ = println!(arr2get {3, 3} (i2sz 3, a, i2sz 1, i2sz 0) : flt)
    val _ = println!(arr2get {3, 3} (i2sz 3, a, i2sz 1, i2sz 1) : flt)
    val _ = println!(arr2get {3, 3} (i2sz 3, a, i2sz 1, i2sz 2) : flt)
    val _ = println!(arr2get {3, 3} (i2sz 3, a, i2sz 2, i2sz 0) : flt)
    val _ = println!(arr2get {3, 3} (i2sz 3, a, i2sz 2, i2sz 1) : flt)
    val _ = println!(arr2get {3, 3} (i2sz 3, a, i2sz 2, i2sz 2) : flt)

    val _ = println!(d[i2sz 0] : flt)
    val _ = println!(d[i2sz 1] : flt)
    val _ = println!(d[i2sz 2] : flt)
*)
  in
    0
  end

(*
   real[][] a = [
      [0.3839264, 0, 0, 0, 0],
      [0.1711146, 0.7542493, 0, 0, 0],
      [0.14420449, 0.28689129, 0.69339598, 0, 0],
      [0.20215693, 0.36993965, 0.21283682, 0.33183608, 0],
      [0.25734144, 0.01083637, 0.41502065, 0.90604563, 0.92236538]
   ];
*)
